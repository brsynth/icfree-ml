'''
Plates generator module

This module generates source and destination plates from
volumes dataframes generated by sampler (or converter) module
'''
import sys
from os import (
    path as os_path,
    makedirs as os_makedirs
)

from brs_utils import (
    create_logger
)

from .plates_generator import (
    extract_dead_volumes,
    src_plate_generator,
    dst_plate_generator
)
from .args import (
    build_args_parser,
    DEFAULT_ARGS
)
from .plate import Plate
from icfree.utils import save_df
from icfree.converter.__main__ import input_importer

# def input_importer(
#     cfps_parameters,
#     volumes,
#     logger: Logger = getLogger(__name__)
# ):
#     """
#     Create volumes dataframes from tsv files

#     Parameters
#     ----------
#     cfps_parameters : tsv file
#         TSV of cfps parameters, status, maximum and stock concentrations
#     volumes : tsv file
#         Dataset with volumes values

#     Returns
#     -------
#     cfps_parameters_df : DataFrame
#         Dataframe with cfps_parameters data
#     volumes_df : DataFrame
#         Dataframe with volumes data
#     """
#     cfps_parameters_df = read_csv(
#         cfps_parameters,
#         sep='[,\t]',
#         engine='python'
#     )
#     logger.debug(f'cfps_parameters_df: {cfps_parameters_df}')

#     volumes_df = read_csv(volumes, sep='[,\t]', engine='python')
#     logger.debug(f'volumes_df: {volumes_df}')

#     return cfps_parameters_df, volumes_df


def main():
    """
    Main function
    """
    parser = build_args_parser(
        program='plates_generator',
        description='Generates source and destination plates'
    )

    args = parser.parse_args()

    # CREATE LOGGER
    logger = create_logger(parser.prog, args.log)

    parameters_df, values_df = input_importer(
        args.parameters,
        args.volumes,
        logger=logger
    )

    values_df['Water'] = \
        args.sample_volume - values_df.sum(axis=1)

    # Exract dead plate volumes from parameters_df
    dead_volumes = extract_dead_volumes(
        parameters_df,
        logger=logger
    )

    # Generate destination plates
    dest_plates = dst_plate_generator(
        volumes=values_df,
        start_well=args.dst_start_well,
        well_capacity=args.dst_plt_well_capacity,
        plate_dead_volume=args.dst_plt_dead_volume,
        vertical=True,
        nplicates=args.nplicates,
        dimensions=args.dst_plt_dim,
        logger=logger
    )

    # Generate source plates
    try:
        # # Handle optional well volumes
        # if args.opt_well_vol == []:
        #     args.opt_well_vol = ['all']
        # upper_volumes, lower_volumes = handle_component_splitting(
        #     args=args,
        #     components=values_df.columns
        # )
        source_plates = src_plate_generator(
            dest_plates=dest_plates,
            plate_dead_volume=args.src_plt_dead_volume,
            well_capacity=args.src_plt_well_capacity,
            param_dead_volumes=dead_volumes,
            start_well=args.src_start_well,
            opt_well_vol=args.opt_well_vol,
            vertical=True,
            dimensions=args.src_plt_dim,
            new_col_comp=args.new_col_comp,
            # upper_volumes=upper_volumes,
            # lower_volumes=lower_volumes,
            logger=logger
        )

        # dest_plates = dst_plate_split_volumes(
        #     dest_plates=dest_plates,
        #     split_comp=split_comp,
        #     logger=logger
        # )
    except IndexError as e:
        logger.error(e)
        logger.error(
            'Exiting...'
        )
        return -1

    # Save source plates
    # Create output folder if it does not exist
    if not os_path.exists(args.output_folder):
        os_makedirs(args.output_folder)
    for i in range(len(source_plates)):
        plt_name = f'{i+1}'
        source_plates[i].to_file(
            os_path.join(
                args.output_folder,
                f'source_plate_{plt_name}.{args.output_format}'
            ),
            args.output_format
        )

    # Save destination plates
    for i in range(len(dest_plates)):
        plt_name = f'{i+1}'
        dest_plates[i].to_file(
            os_path.join(
                args.output_folder,
                f'destination_plate_{plt_name}.{args.output_format}'
            ),
            args.output_format
        )

    # Save volumes summary
    volumes_summary = Plate.get_volumes_summary(
        source_plates,
        'pandas',
        logger=logger
    )
    save_df(
        df=volumes_summary,
        outfile='volumes_summary.tsv',
        output_folder=args.output_folder,
        index=True,
        logger=logger
    )

    # Print out
    if not args.silent:
        # SRC PLT
        print("SOURCE PLATES")
        print("=============")
        for plate in source_plates:
            print(plate.to_df_rc())
            print()
        # DST PLT
        print("DESTINATION PLATES")
        print("==================")
        for plate in dest_plates:
            print(plate.to_df_rc())
            print()



def handle_component_splitting(
    args,
    components: list,
):
    """
    Handle component splitting

    Parameters
    ----------
    args : list
        List of args
    components : list
        List of components

    Returns
    -------
    upper_volumes : list
        List of upper volumes
    lower_volumes : list
        List of lower volumes
    """

    # Handle component splitting
    # src_plt_split_upper_volumes
    spsuv_d = {}
    spsuv = args.src_plt_split_upper_vol
    # src_plt_split_lower_volumes
    spslv_d = {}
    spslv = args.src_plt_split_lower_vol
    # src_plt_split_component
    spsc = args.src_plt_split_component
    # Fill component limits only if the upper limit
    # has been specified by the user
    if spsuv != DEFAULT_ARGS['SRC_PLT_SPLIT_UPPER_VOL']:
        if spsc == DEFAULT_ARGS['SRC_PLT_SPLIT_COMPONENT']:
            # Copy bounds to all components
            for component in components:
                spsuv_d[component] = spsuv
                spslv_d[component] = spslv
        else:
            # If one of spsuv and spslv
            # has one single value, then extend to the number of components
            if len(spsuv) == 1:
                spsuv = [spsuv[0]] * len(spsc)
            if len(spslv) == 1:
                spslv = [spslv[0]] * len(spsc)
            # Copy bounds to specified components
            for i in range(len(spsc)):
                spsuv_d[spsc[i]] = spsuv[i]
                spslv_d[spsc[i]] = spslv[i]

    return spsuv_d, spslv_d


if __name__ == "__main__":
    sys.exit(main())
