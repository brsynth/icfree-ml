from logging import getLogger, Logger
import numpy as np
import pandas as pd
from itertools import product
from scipy.stats import qmc

from .args import DEFAULTS


def load_data(
    file_path: str,
    logger: Logger = getLogger(__name__)
) -> tuple:
    """
    Load and prepare data from a CSV file.

    Parameters:
    - file_path : str
        The file path to the CSV file.
    - logger : Logger, optional
        The logger object for logging messages.

    Returns:
    - pd.DataFrame
        The loaded data.
    """
    logger.info("Loading data from file.")
    data = pd.read_csv(file_path, delimiter='\t')
    # replace NaN in Ratios|Step|NbBins with empty string
    data['Ratios|Step|NbBins'] = data['Ratios|Step|NbBins'].fillna('1||')
    return data


def extract_specs(
    spec: str,
    logger: Logger = getLogger(__name__)
) -> tuple:
    """
    Extract ratios, step, and nb_bins from the specification string.

    Parameters:
    - spec (str): The specification string containing
    ratios, step, and nb_bins separated by '|'.
    - logger : Logger, optional
        The logger object for logging messages.

    Returns:
    - ratios (list): A list of floats representing
    the ratios extracted from the specification string.
    - step (int): The step value extracted from the specification string.
    - nb_bins (int): The number of bins extracted from
    the specification string.
    """
    ratios, step, nb_bins = None, None, None
    if spec == "":
        return ratios, step, nb_bins
    values = spec.split('|')
    # If values has one value, then it is ratios
    if len(values) == 1:
        values = [values[0], '', '']
    # Check values length, if not 3, raise an error
    if len(values) != 3:
        raise ValueError("Invalid specification string.")

    if values[0]:
        ratios = [float(r) for r in values[0].split(',')]
    else:
        ratios = None
    if values[1]:
        step = int(values[1])
    else:
        step = None
    if values[2]:
        nb_bins = int(values[2])
    else:
        nb_bins = None

    return ratios, step, nb_bins


def generate_ranges_by_ratios(
    max_value: float,
    ratios: list,
    logger: Logger = getLogger(__name__)
) -> list:
    """
    Generate discrete ranges based on specified ratios.

    Args:
        max_value (float): The maximum value for the range.
        ratios (list): A list of ratios representing
        the proportions of each range.
        logger : Logger, optional
        The logger object for logging messages.

    Returns:
        list: A list of discrete ranges based on the specified ratios.

    Example:
        >>> generate_ranges_by_ratios(100, [0.2, 0.3, 0.5])
        [20, 50, 100]
    """
    return [round(max_value * ratio) for ratio in ratios]
    # total_ratio = sum(ratios)
    # cumulative_ratio = 0
    # range_list = []
    # for ratio in ratios[:-1]:
    #     cumulative_ratio += ratio
    #     next_value = round((cumulative_ratio / total_ratio) * max_value)
    #     range_list.append(next_value)
    # range_list.append(max_value)
    # return range_list


def generate_ranges_by_step(
    max_value: int,
    step: int,
    logger: Logger = getLogger(__name__)
) -> list:
    """
    Generate discrete ranges based on a step value.

    Parameters:
    - max_value (int): The maximum value for the range.
    - step (int): The step value for generating the ranges.

    Returns:
    - list: A list of discrete ranges generated based on the step value.
    """
    # Check if step is non-negative
    if step < 0:
        raise ValueError("Step should be non-negative.")
    return list(range(0, max_value + 1, step))


def generate_ranges_by_nbins(
    max_value: float,
    nb_bins: int,
    logger: Logger = getLogger(__name__)
) -> list:
    """
    Generate discrete ranges by dividing the maxValue into nb_bins equal parts.

    Parameters:
    - max_value (float): The maximum value to be divided into ranges.
    - nb_bins (int): The number of bins to divide the max_value into.

    Returns:
    - list: A list of discrete ranges generated by dividing the max_value into
    nb_bins equal parts.
    """
    if nb_bins < 0:
        raise ValueError("Number of bins should be non-negative.")
    step = max_value / nb_bins
    return [round(step * i) for i in range(nb_bins + 1)]


def generate_discrete_ranges(
    data: pd.DataFrame,
    logger: Logger = getLogger(__name__)
) -> list:
    """
    Generate discrete ranges based on the DataFrame.

    Parameters:
    - data: DataFrame containing the data.

    Returns:
    - discrete_ranges: List of discrete ranges generated based on the data.

    This function iterates over the rows of the input DataFrame and
    generates discrete ranges based on the values in each row.
    It extracts specifications from the 'Ratios|Step|NbBins' column and
    uses them to determine the ranges. If multiple specifications are found,
    warnings are issued. The generated ranges are then appended to
    the 'discrete_ranges' list, which is returned at the end.

    Note: The 'Ratios|Step|NbBins' column should contain the specifications
    in the format 'ratios|step|nb_bins',
    where 'ratios' is a comma-separated list of ratios,
    'step' is the step size, and
    'nb_bins' is the number of bins.
    """

    discrete_ranges = []
    for _, row in data.iterrows():
        ratios, step, nb_bins = extract_specs(row['Ratios|Step|NbBins'])
        if ratios:
            if step or nb_bins:
                logger.warning(
                    f"Multiple specifications found for {row['Component']}."
                    " Using Ratios."
                )
            ranges = generate_ranges_by_ratios(row['maxValue'], ratios)
        elif step:
            if nb_bins:
                logger.warning(
                    f"Both Step and NbBins provided for {row['Component']}."
                    " Using Step."
                )
            ranges = generate_ranges_by_step(row['maxValue'], step)
        elif nb_bins:
            ranges = generate_ranges_by_nbins(row['maxValue'], nb_bins)
        else:
            ranges = []
        discrete_ranges.append(ranges)
    return discrete_ranges


def get_discrete_ranges(
    data: pd.DataFrame,
    ratios: list,
    step: int,
    nb_bins: int,
    logger: Logger = getLogger(__name__)
) -> list:
    """
    Get the discrete ranges for each component.

    Parameters:
    - data : pd.DataFrame
        The loaded data.
    - ratios : list
        The ratios for each component.
    - step : int
        The step size for creating discrete ranges.
    - nb_bins : int
        The number of bins for creating discrete ranges.
    - logger : Logger, optional
        The logger object for logging messages.

    Returns:
    - list
        The discrete ranges for each component.
    """
    logger.info("Creating discrete ranges.")

    # If args.ratios set, use them to create the discrete ranges
    if ratios is not None:
        # for each component, generate the discrete ranges
        # by taking each ratios and multiplying it by the max value
        discrete_ranges = [
            generate_ranges_by_ratios(max_val, ratios)
            for max_val in data['maxValue']
        ]
    # If args.step, use it to create the discrete ranges
    elif step is not None:
        discrete_ranges = [
            generate_ranges_by_step(max_val, step)
            for max_val in data['maxValue']
        ]
    # If args.nb_bins set, use it to create the discrete ranges
    elif nb_bins is not None:
        discrete_ranges = [
            generate_ranges_by_nbins(max_val, nb_bins)
            for max_val in data['maxValue']
        ]
    # Otherwise, use content file to create the discrete ranges
    else:
        discrete_ranges = generate_discrete_ranges(data)
    return discrete_ranges


def gen_samples(
    discrete_ranges: list,
    sampler: qmc.LatinHypercube,
    n_samples: int,
    seed: int = None,
    logger: Logger = getLogger(__name__)
) -> np.ndarray:
    """
    Generate samples from the given discrete ranges.

    Parameters:
    - discrete_ranges : list of lists
        The discrete ranges for each component.
    - sampler : scipy.stats.qmc.LatinHypercube
        The sampler object for generating samples.
    - n_samples : int
        The number of samples to generate.
    - seed : int, optional
        The seed value for random number generation.
    - logger : Logger, optional
        The logger object for logging messages.

    Returns:
    - np.ndarray
        The generated samples.
    """
    if discrete_ranges == []:
        return np.array([])
    if seed is not None:
        np.random.seed(seed)  # Set the seed for reproducibility
    samples_unit = sampler.random(n=n_samples)
    samples_indices = np.floor(
        samples_unit * [len(r) for r in discrete_ranges]
    ).astype(int)
    # Initialize an empty array to hold the scaled samples
    samples_scaled_discrete = np.zeros(samples_indices.shape)
    # Convert indices to actual values in the discrete space
    for dim in range(len(discrete_ranges)):
        samples_scaled_discrete[:, dim] = [
            list(discrete_ranges[dim])[idx]
            for idx in samples_indices[:, dim]
        ]
    return samples_scaled_discrete


def replace_duplicates(
    samples_df: pd.DataFrame,
    discrete_ranges: list,
    sampler: qmc.LatinHypercube,
    seed: int = None,
    logger: Logger = getLogger(__name__)
) -> pd.DataFrame:
    """
    Replace duplicates in the samples DataFrame.

    Parameters:
    - samples_df : pd.DataFrame
        The DataFrame containing the samples.
    - discrete_ranges : list of lists
        The discrete ranges for each component.
    - sampler : scipy.stats.qmc.LatinHypercube
        The sampler object for generating samples.
    - seed : int
        The seed value for random number generation.
    - logger : Logger, optional
        The logger object for logging messages.

    Returns:
    - pd.DataFrame
        The DataFrame with duplicates replaced.
    """
    logger.warning("Replacing duplicates with random samples.")

    nb_possible_combinations = np.prod([len(r) for r in discrete_ranges])

    # Checks to prevent infinite loop
    # If length of samples_df > possible combinations, raise an error
    if len(samples_df) > nb_possible_combinations:
        raise ValueError("Number of samples exceeds total combinations.")
    # Else if length of samples_df == possible combinations,
    # return all combinations
    elif len(samples_df) == nb_possible_combinations:
        # return all possible combinations from discrete_ranges
        return generate_all_combinations(discrete_ranges, logger)

    if seed is not None:
        np.random.seed(seed)

    while samples_df.duplicated().any():
        # Keep the first occurrence of each duplicate,
        # and build the mask with the remaining duplicates
        duplicate_mask = samples_df.duplicated(keep='first')
        # Number of new samples to generate
        num_duplicates = duplicate_mask.sum()
        samples = gen_samples(
            discrete_ranges, sampler, num_duplicates, seed, logger
        )
        # Convert the scaled samples to DataFrame
        new_samples_df = pd.DataFrame(samples)
        new_samples_df.columns = samples_df.columns
        # Replace the duplicates with the new samples
        samples_df.loc[duplicate_mask, :] = new_samples_df.values

    return samples_df


def random_sampling(
    discrete_ranges: list,
    n_samples: int,
    seed: int = None,
    logger: Logger = getLogger(__name__)
) -> np.ndarray:
    """
    Generate random samples.

    Parameters:
    - discrete_ranges : list of lists
        The discrete ranges for each component.
    - n_samples : int
        The number of samples to generate.
    - logger : Logger, optional
        The logger object for logging messages.

    Returns:
    - np.ndarray
        The generated random samples.
    """
    # CHeck for non-negative number of samples
    if n_samples < 0:
        raise ValueError("Number of samples should be non-negative.")
    logger.info("Proceeding with random sampling.")
    np.random.seed(seed)  # Set the seed for reproducibility
    samples = np.array(
        [
            [np.random.choice(range_) for range_ in discrete_ranges]
            for _ in range(n_samples)
        ]
    )
    return samples


def generate_all_combinations(
    discrete_ranges: list,
    logger: Logger = getLogger(__name__)
) -> np.ndarray:
    """
    Generate all possible combinations.

    Parameters:
    - discrete_ranges : list of lists
        The discrete ranges for each component.
    - logger : Logger, optional
        The logger object for logging messages.

    Returns:
    - np.ndarray
        All possible combinations of the given ranges.
    """
    logger.info("Generating all possible combinations.")
    all_combinations = np.array(list(product(*discrete_ranges)))
    return all_combinations


def sampling(
    discrete_ranges: list,
    n_samples: int,
    method: str = DEFAULTS['method'],
    seed: int = None,
    logger: Logger = getLogger(__name__)
) -> pd.DataFrame:
    """
    Adapted sampling method based on the number of samples and
    total combinations.

    Parameters:
    - discrete_ranges : list of lists
        The discrete ranges for each component.
    - n_samples : int
        The number of samples to generate.
    - method : str, optional
        The sampling method to use ('auto', 'lhs', 'random', 'all').
        'lhs' for Latin Hypercube Sampling, 'random' for random sampling,
        'all' for generating all combinations, and 'auto' for automatic
        selection based on the number of samples and total combinations.
        If the number of samples is less than or equal to one third of
        the total combinations, LHS sampling is used. If the number of
        samples is greater than one third of the total combinations and
        less than the total combinations, random sampling is used. If the
        number of samples equals the total combinations, all combinations
        are generated. The default is 'auto'.
    - seed : int, optional
        The seed value for random number generation.
    - logger : Logger, optional
        The logger object for logging messages.

    Returns:
    - pd.DataFrame
        The DataFrame containing the generated samples.
    """

    # Check if discrete_ranges is empty
    if discrete_ranges == []:
        return pd.DataFrame([])

    logger.info("Starting adapted sampling method.")
    np.random.seed(seed)  # Set the seed for reproducibility
    N = np.prod([len(r) for r in discrete_ranges])
    logger.info(f"Total combinations: {N}")
    logger.info(f"Number of samples: {n_samples}")

    sampler = qmc.LatinHypercube(
        d=len(discrete_ranges),
        # optimization='random-cd',
        seed=seed
    )

    # LHS sampling
    if method == 'lhs' or method == 'auto' and n_samples <= N / 3:
        samples_df = pd.DataFrame(
            gen_samples(discrete_ranges, sampler, n_samples, seed, logger)
        )
        if samples_df.duplicated().any():
            samples_df = replace_duplicates(
                samples_df, discrete_ranges, sampler, seed, logger
            )

    # Random sampling
    elif method == 'random' or method == 'auto' and N / 3 < n_samples < N:
        logger.info("Number of samples high relative to combinations."
                    " Using random sampling.")
        samples_df = pd.DataFrame(
            random_sampling(discrete_ranges, n_samples, seed, logger)
        )

    # Generate all combinations
    elif method == 'all' or method == 'auto' and n_samples == N:
        logger.info("Number of samples equals total combinations."
                    " Generating all combinations.")
        samples_df = pd.DataFrame(
            generate_all_combinations(discrete_ranges, logger)
        )

    # Invalid number of samples
    else:
        raise ValueError("Number of samples exceeds total combinations.")

    return samples_df
